<html>
<head>
<title>Mines.java</title>
</head>
<body>
<pre>

import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;
import java.lang.Math;
import java.util.EventObject;
import java.util.Calendar;

public class Mines extends java.applet.Applet implements Runnable, ActionListener, MouseListener {

   private Label counter;
   private Button newGame;
   private GameButton[][] b = new GameButton[8][8];
   private GridBagLayout gbLayout;
   private GridBagConstraints gbConstraints;

   private int numMines = 10;     //The number of mines to be laid - may be raised to make game harder
   private int minesLeft;
   private int buttonCount;
   private int lastTime;          //for timer
   private int newTime;           //for timer
   private int timeElapsed = 0;   //for timer

   private SuccessDialog myDialog;
   private boolean show = false;

   private boolean checkAgain = false;
   private boolean firstClick = true;
   private boolean gameOver = false;
   private boolean runClock = false;

   private Label timer;
   Thread clock;
   private Calendar c;
   Font f1 = new Font(&quot;SansSerif&quot;, Font.BOLD, 14);
   	
   //--------------------------------------------------------------------------------------------
   public void init() {

      int i;                      //loop counter
      int j;                      //loop counter

      gbLayout = new GridBagLayout();
      setLayout(gbLayout);             //applet (?)
      gbConstraints = new GridBagConstraints();

      counter = new Label (&quot; Mines: &quot;);
      counter.setFont(f1);
      counter.setBackground(Color.lightGray);


      newGame = new Button (&quot;Reset&quot;);
      newGame.setFont(f1);
      newGame.setBackground(Color.yellow);
      newGame.setActionCommand(&quot;startOver&quot;);
      newGame.addActionListener(this);

      timer = new Label(&quot; Timer: 0&quot;);
      timer.setFont(f1);
      timer.setBackground(Color.lightGray);

      gbConstraints.fill = GridBagConstraints.HORIZONTAL;
      addComponent(counter,0,0,3,1);
      addComponent(newGame,0,3,2,1);
      addComponent(timer,0,5,3,1);

      //get buttons ready (added to layout manager in the setUp() method
      for (i= 0; i &lt; 8; i++) {
         for (j = 0; j &lt; 8; j++) {
            b[i][j] = new GameButton(&quot;     &quot;);
            //set command to be grid reference (without top row)
            b[i][j].setActionCommand(Integer.toString(i) + &quot; &quot; + Integer.toString(j));
            b[i][j].addActionListener(this);
            b[i][j].addMouseListener(this);
         }
      }

      setUp();
      //set variables for timer
      c = Calendar.getInstance();
      lastTime = c.get(Calendar.SECOND);
   }

   //--------------------------------------------------------------------------------------------
   private void addComponent(Component c, int row, int column, int width, int height) {
   //The method addComponent is programmer defined:

      //set gridx and gridy
      gbConstraints.gridx = column;
      gbConstraints.gridy = row;

      //set gridwidth and gridheight
      gbConstraints.gridwidth = width;
      gbConstraints.gridheight = height;

      //set constraints
      gbLayout.setConstraints(c, gbConstraints);
      add(c);  //add component to applet
   }

   //--------------------------------------------------------------------------------------------
   public void setUp() {
      int i;                      //loop counter
      int j;                      //loop counter

      //add buttons and set (or reset) each
      for (i= 0; i &lt; 8; i++) {
         for (j = 0; j &lt; 8; j++) {
            addComponent((b[i][j]), i+1, j, 1,1);   //Starts at 1 - the 2nd row - because the top row is used
            b[i][j].setFont(f1);
            b[i][j].setForeground(Color.black);
            b[i][j].setLabel(&quot;     &quot;);
            b[i][j].setMinePresent(false);
            b[i][j].setFlagged(false);
            b[i][j].setQuestioned(false);
            b[i][j].setAlreadyIdentified(false);
            b[i][j].setMinesNearby(0);
            b[i][j].setMoreToCheck(false);
         }
      }
      firstClick = true;
      gameOver=false;
      buttonCount=0;
      minesLeft=numMines;
      counter.setText(&quot; Mines: &quot; + Integer.toString(minesLeft));
      // setting the mines is done after the first click
   }

   //--------------------------------------------------------------------------------------------
   public void setMines(int numMines, int firstX, int firstY) {

      int i;                      //loop counter
      int j;                      //loop counter
      int row;
      int column;
      int startRow;
      int endRow;
      int startColumn;
      int endColumn;
      int minesClose;

      int[] r = new int[numMines];     //to hold the row numbers where there are mines
      int[] c = new int[numMines];     //to hold the column numbers for each mine in the rows

      //firstX is row of first click after new game starts
      //firstY is row of first click after new game starts

      //set mines
      for (i=0; i &lt; numMines; i++) {
         r[i] = (int)(Math.random() * 8);
         c[i] = (int)(Math.random() * 8);

         //confirm that there is not a mine already at that location and not at first click position
         if ( ((b[r[i]][c[i]]).getMinePresent() == true) || ((r[i] == firstX) & (c[i] == firstY)))
            i--;
         else {
            (b[r[i]][c[i]]).setMinePresent(true);
            System.out.println(&quot;Mine set at: &quot; + r[i] + &quot;, &quot; + c[i]);
         }
      }  // end of setting mines

      //set minesNearby variable for each GameButton
      for (i= 0; i &lt; 8; i++) {
         for (j = 0; j &lt; 8; j++) {

            if (i==0)
               startRow = 0;
            else
               startRow = i - 1;

            if (i == 7)
               endRow = 7;
            else
               endRow = i + 1;

            if (j==0)
               startColumn = 0;
            else
               startColumn = j - 1;

            if (j==7)
               endColumn = 7;
            else
               endColumn = j + 1;

            minesClose = 0;

            for(row = startRow; row &lt;= endRow; row++) {
               for(column = startColumn; column &lt;= endColumn; column++) {

                  if(((row == i) && (column ==j))==false) {  //to avoid testing the current button

                     if(b[row][column].getMinePresent() == true)
                        minesClose++;
                  }
               }
            }
            b[i][j].setMinesNearby(minesClose);
         }
      }  // end of setting minesNearby variable for each GameButton
   }

   //--------------------------------------------------------------------------------------------
   public void actionPerformed(ActionEvent a) {
      int thisX;
      int thisY;
      int blankPosn;
      String loc;

      loc = a.getActionCommand();    //using the command, not the label to identify button
      if(loc.equals(&quot;startOver&quot;)) {
         System.out.println(&quot;Start a new game&quot;);
         setUp();
         resetTimer();
      }
      else if (!gameOver){
         blankPosn = loc.indexOf(&quot; &quot;);
         thisX = Integer.parseInt(loc.substring(0, blankPosn));
         thisY = Integer.parseInt(loc.substring(blankPosn + 1));

         //Note that functions for right-clicks are handled in the mouseClick() method below

         //Don't do anything if button already identified (will alter buttonCount if allowed)
         if ((b[thisX][thisY]).getAlreadyIdentified() == false) {  

            //remove flag if (incorrectly) placed at this location and update counter
            if (firstClick == true) {
               setMines(numMines, thisX, thisY);
               firstClick = false;
               runClock = true;  //starts timer
               start();
            }

            if((b[thisX][thisY]).getMinePresent()==true) {
               gameOver();
            }
            else {
               //remove a flag and increase counter if there is one there already
               if((b[thisX][thisY]).getFlagged()==true) {
                  b[thisX][thisY].setFlagged(false);
                  minesLeft++;
                  counter.setText(&quot; Mines: &quot; + Integer.toString(minesLeft));
               }

               //Determine how many mines there are in the surrounding 8 cells
               (b[thisX][thisY]).getMinesNearby(b[thisX][thisY]);
               b[thisX][thisY].setAlreadyIdentified(true);    
            
               buttonCount++;

               //If there are no mines in the surrounding 8 cells, test those surrounding cells too.
               if ((b[thisX][thisY]).getMinesNearby(b[thisX][thisY]) == 0)
                  testAdjacent(thisX,thisY);

               finishGame();  //test for successful end of game
            }
         }
      }
   }  
   //--------------------------------------------------------------------------------------------
   public void testAdjacent(int r, int c) {

      int row;
      int startRow;
      int endRow;
      int col;
      int startCol;
      int endCol;

      b[r][c].setMoreToCheck(false);         //so testAdjacent() will not run again unless reset below
      remove(b[r][c]);                       //removes the visible button but GameButton b[r][c] still exists				

      if (r==0)
         startRow = 0;
      else
         startRow = r - 1;

      if (r == 7)
         endRow = 7;
      else
         endRow = r + 1;

      if (c==0)
         startCol = 0;
      else
         startCol = c - 1;

      if (c==7)
         endCol = 7;
      else
         endCol = c + 1;

      for(row = startRow; row &lt;= endRow; row++) {
         for (col = startCol; col &lt;= endCol; col++) {

            if(b[row][col].getAlreadyIdentified() == false) {

               //remove flag if (incorrectly) placed at this location and update counter
               if((b[row][col]).getFlagged()==true) {
                  b[row][col].setFlagged(false);
                  minesLeft++;
                  counter.setText(&quot; Mines: &quot; + Integer.toString(minesLeft));
               }

               if (b[row][col].getMinesNearby(b[row][col]) == 0) {
                  remove(b[row][col]);
                  b[row][col].setMoreToCheck(true);
                  checkAgain = true;
               }

            b[row][col].setAlreadyIdentified(true);
            buttonCount++;
            }
         }
      }
   checkAgain();
   }

   //--------------------------------------------------------------------------------------------
   public void checkAgain() {

      int row;
      int col;

      while(checkAgain == true) {
         checkAgain = false;

         for (row = 0; row &lt; 8; row++) {
            for (col = 0; col &lt; 8; col++) {
               if (b[row][col].getMoreToCheck() == true) {
                  checkAgain = true;
                  testAdjacent(row, col);
               }
            }
         }

      }
   }

   //--------------------------------------------------------------------------------------------
   public void gameOver() {

      int row;
      int col;

      for (row = 0; row &lt; 8; row++) {
         for (col = 0; col &lt; 8; col++) {
            if (b[row][col].getMinePresent() == true) {
               b[row][col].setForeground(Color.black);
               b[row][col].setLabel(&quot;M&quot;);
               gameOver = true;
               runClock = false;   //stop the clock
            }
         }
      }
   }

   //--------------------------------------------------------------------------------------------
   public void finishGame() {

      //the game is successfully completed when every square is accounted for 
      if ((minesLeft == 0) && (buttonCount == (64 - numMines))) {  

         gameOver = true;    //to disable buttons except Reset
         System.out.println(&quot;You win!&quot;);
         runClock = false;   //stop the timer

         //display dialog box informing of victory
         if (myDialog == null) {
            // This traverses upwards until it finds a frame, this way
            // finding a frame should work independently of how the applet
            // browser is implemented (e.g. Netscape versus appletviewer).
            Object frame = getParent();
            while (!(frame instanceof Frame))
            frame = ((Component) frame).getParent();
            myDialog = new SuccessDialog((Frame) frame, &quot;Congratulations!&quot;);
           }
           myDialog.show();
      }      
}

   //--------------------------------------------------------------------------------------------

   public void mouseEntered(MouseEvent m) {}
   public void mouseExited(MouseEvent m) {}
   public void mousePressed(MouseEvent m) {}
   public void mouseReleased(MouseEvent m) {}

   public void mouseClicked (MouseEvent e) {  
      int thisX;
      int thisY;
      int blankPosn;
      String where;

      where = ((GameButton)e.getSource()).getActionCommand();
      blankPosn = where.indexOf(&quot; &quot;);
      thisX = Integer.parseInt(where.substring(0, blankPosn));
      thisY = Integer.parseInt(where.substring(blankPosn + 1));

         //test for right mouse click - change to flagged then questioned
         if(e.isMetaDown() == true) {
            System.out.println(&quot;Right mouse click at: &quot; + thisX + &quot; &quot; + thisY);

               if((b[thisX][thisY]).getAlreadyIdentified()==false) {

                  if((b[thisX][thisY]).getFlagged()==false) {
                     b[thisX][thisY].setFlagged(true);
                     minesLeft--;
                     b[thisX][thisY].setQuestioned(false);
                     b[thisX][thisY].setForeground(Color.yellow);
                     b[thisX][thisY].setLabel(&quot;F&quot;);
                     counter.setText(&quot; Mines: &quot; + Integer.toString(minesLeft));
                     finishGame();  //test for successful end of game
                  }
                  else {
                     b[thisX][thisY].setFlagged(false);
                     minesLeft++;
                     b[thisX][thisY].setQuestioned(true);
                     b[thisX][thisY].setForeground(Color.red);
                     b[thisX][thisY].setLabel(&quot;?&quot;);
                     counter.setText(&quot; Mines: &quot; + Integer.toString(minesLeft));
                  }
               }
           }
      else
      System.out.println(&quot;Left mouse click at: &quot; + thisX + &quot; &quot; + thisY);

   }

   //--------------------------------------------------------------------------------------------
   //Methods associated with timer

   public void start() {
      clock = new Thread(this);
      clock.start();
   }

   public void stop() {
      if (clock != null) {
         clock.stop();
         clock = null;
      }
   }

   public void run() {
      Calendar d;

      while(runClock) {
         d = Calendar.getInstance();
         newTime = d.get(Calendar.SECOND);
         if (newTime != lastTime)
            timeElapsed++;
         try {Thread.sleep(250);}
         catch (InterruptedException e) {}
         lastTime = newTime;
         timer.setText(&quot; Time: &quot; + Integer.toString(timeElapsed));
      }
   }

   public void resetTimer() {
      lastTime = 0;
      newTime = 0;
      timeElapsed = 0;
      timer.setText(&quot; Time: 0&quot;);
      runClock = false;
   }

   //--------------------------------------------------------------------------------------------

}

</pre>
</body>
</html>
